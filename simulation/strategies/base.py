"""
PredictBot Simulation - Base Strategy Adapter
==============================================

Abstract base class for strategy adapters that wrap existing
PredictBot strategies for use in simulation.
"""

import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import List, Optional, Dict, Any

from ..models import (
    MarketSnapshot,
    OrderBookSnapshot,
    Platform,
    OrderSide,
    OrderType,
    Order,
    SimulationEvent,
    MarketUpdateEvent,
)
from ..portfolio import VirtualPortfolio


logger = logging.getLogger(__name__)


class SignalType(str, Enum):
    """Types of trading signals."""
    BUY_YES = "BUY_YES"
    BUY_NO = "BUY_NO"
    SELL_YES = "SELL_YES"
    SELL_NO = "SELL_NO"
    HOLD = "HOLD"
    CLOSE = "CLOSE"  # Close existing position


@dataclass
class StrategySignal:
    """
    Trading signal generated by a strategy.
    
    Represents a recommendation to take action on a market.
    """
    signal_type: SignalType
    market_id: str
    platform: Platform
    timestamp: datetime
    confidence: float = 1.0  # 0.0 to 1.0
    target_price: Optional[float] = None
    size: Optional[float] = None  # Suggested position size
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    reason: str = ""
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_order(
        self,
        order_id: str,
        default_size: float = 100.0,
    ) -> Optional[Order]:
        """
        Convert signal to an order.
        
        Args:
            order_id: Unique order ID
            default_size: Default size if not specified in signal
            
        Returns:
            Order object or None if signal is HOLD
        """
        if self.signal_type == SignalType.HOLD:
            return None
        
        # Map signal type to order side
        side_map = {
            SignalType.BUY_YES: OrderSide.BUY_YES,
            SignalType.BUY_NO: OrderSide.BUY_NO,
            SignalType.SELL_YES: OrderSide.SELL_YES,
            SignalType.SELL_NO: OrderSide.SELL_NO,
        }
        
        if self.signal_type == SignalType.CLOSE:
            # Close signal needs to be converted based on position
            return None
        
        side = side_map.get(self.signal_type)
        if not side:
            return None
        
        return Order(
            order_id=order_id,
            market_id=self.market_id,
            platform=self.platform,
            side=side,
            order_type=OrderType.LIMIT if self.target_price else OrderType.MARKET,
            size=self.size or default_size,
            limit_price=self.target_price,
            created_at=self.timestamp,
            metadata={
                "signal_confidence": self.confidence,
                "signal_reason": self.reason,
                "stop_loss": self.stop_loss,
                "take_profit": self.take_profit,
            }
        )


class BaseStrategyAdapter(ABC):
    """
    Abstract base class for strategy adapters.
    
    Adapters wrap existing PredictBot strategies to work with
    the simulation framework. They receive market events and
    generate trading signals.
    """
    
    def __init__(
        self,
        name: str,
        platforms: Optional[List[Platform]] = None,
        max_positions: int = 10,
        position_size: float = 100.0,
        risk_per_trade: float = 0.02,  # 2% of portfolio
    ):
        """
        Initialize strategy adapter.
        
        Args:
            name: Strategy name
            platforms: Platforms this strategy trades on
            max_positions: Maximum concurrent positions
            position_size: Default position size
            risk_per_trade: Maximum risk per trade as fraction of portfolio
        """
        self.name = name
        self.platforms = platforms or list(Platform)
        self.max_positions = max_positions
        self.position_size = position_size
        self.risk_per_trade = risk_per_trade
        
        # State tracking
        self._market_state: Dict[str, MarketSnapshot] = {}
        self._orderbook_state: Dict[str, OrderBookSnapshot] = {}
        self._signals_generated: List[StrategySignal] = []
        self._is_initialized = False
    
    @abstractmethod
    def on_market_update(
        self,
        event: MarketUpdateEvent,
        portfolio: VirtualPortfolio,
    ) -> List[StrategySignal]:
        """
        Process a market update event.
        
        Args:
            event: Market update event
            portfolio: Current portfolio state
            
        Returns:
            List of trading signals (can be empty)
        """
        pass
    
    def on_orderbook_update(
        self,
        market_id: str,
        orderbook: OrderBookSnapshot,
        portfolio: VirtualPortfolio,
    ) -> List[StrategySignal]:
        """
        Process an order book update.
        
        Override in subclasses that use order book data.
        
        Args:
            market_id: Market identifier
            orderbook: Order book snapshot
            portfolio: Current portfolio state
            
        Returns:
            List of trading signals
        """
        self._orderbook_state[market_id] = orderbook
        return []
    
    def on_resolution(
        self,
        market_id: str,
        outcome: str,
        portfolio: VirtualPortfolio,
    ) -> List[StrategySignal]:
        """
        Process a market resolution.
        
        Override in subclasses that need to react to resolutions.
        
        Args:
            market_id: Market identifier
            outcome: Resolution outcome (YES/NO)
            portfolio: Current portfolio state
            
        Returns:
            List of trading signals
        """
        # Remove from state
        self._market_state.pop(market_id, None)
        self._orderbook_state.pop(market_id, None)
        return []
    
    def initialize(self, portfolio: VirtualPortfolio):
        """
        Initialize strategy with portfolio state.
        
        Called once before processing events.
        """
        self._is_initialized = True
        logger.info(f"Strategy '{self.name}' initialized")
    
    def finalize(self, portfolio: VirtualPortfolio):
        """
        Finalize strategy after all events processed.
        
        Called once after all events are processed.
        """
        logger.info(
            f"Strategy '{self.name}' finalized. "
            f"Generated {len(self._signals_generated)} signals."
        )
    
    def get_market_state(self, market_id: str) -> Optional[MarketSnapshot]:
        """Get current state for a market."""
        return self._market_state.get(market_id)
    
    def get_orderbook(self, market_id: str) -> Optional[OrderBookSnapshot]:
        """Get current order book for a market."""
        return self._orderbook_state.get(market_id)
    
    def update_market_state(self, snapshot: MarketSnapshot):
        """Update internal market state."""
        self._market_state[snapshot.market_id] = snapshot
    
    def calculate_position_size(
        self,
        portfolio: VirtualPortfolio,
        price: float,
        confidence: float = 1.0,
    ) -> float:
        """
        Calculate position size based on portfolio and risk parameters.
        
        Args:
            portfolio: Current portfolio
            price: Entry price
            confidence: Signal confidence (0-1)
            
        Returns:
            Position size in contracts
        """
        # Risk-based position sizing
        portfolio_value = portfolio.total_value
        risk_amount = portfolio_value * self.risk_per_trade * confidence
        
        # Calculate size based on risk
        # For binary options, max loss is price * size
        if price > 0:
            max_size = risk_amount / price
        else:
            max_size = self.position_size
        
        # Apply limits
        return min(max_size, self.position_size)
    
    def should_trade(
        self,
        market_id: str,
        portfolio: VirtualPortfolio,
    ) -> bool:
        """
        Check if strategy should trade this market.
        
        Args:
            market_id: Market identifier
            portfolio: Current portfolio
            
        Returns:
            True if trading is allowed
        """
        # Check max positions
        if len(portfolio.positions) >= self.max_positions:
            return False
        
        return True
    
    def _record_signal(self, signal: StrategySignal):
        """Record a generated signal for analysis."""
        self._signals_generated.append(signal)
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get strategy statistics."""
        signals_by_type = {}
        for signal in self._signals_generated:
            signal_type = signal.signal_type.value
            signals_by_type[signal_type] = signals_by_type.get(signal_type, 0) + 1
        
        return {
            "name": self.name,
            "total_signals": len(self._signals_generated),
            "signals_by_type": signals_by_type,
            "markets_tracked": len(self._market_state),
        }


class CompositeStrategy(BaseStrategyAdapter):
    """
    Combines multiple strategies into one.
    
    Useful for running multiple strategies together and
    combining their signals.
    """
    
    def __init__(
        self,
        strategies: List[BaseStrategyAdapter],
        name: str = "CompositeStrategy",
        signal_aggregation: str = "all",  # "all", "any", "majority"
    ):
        """
        Initialize composite strategy.
        
        Args:
            strategies: List of strategies to combine
            name: Strategy name
            signal_aggregation: How to aggregate signals
        """
        super().__init__(name=name)
        self.strategies = strategies
        self.signal_aggregation = signal_aggregation
    
    def on_market_update(
        self,
        event: MarketUpdateEvent,
        portfolio: VirtualPortfolio,
    ) -> List[StrategySignal]:
        """Aggregate signals from all strategies."""
        all_signals = []
        
        for strategy in self.strategies:
            signals = strategy.on_market_update(event, portfolio)
            all_signals.extend(signals)
        
        # Aggregate based on mode
        if self.signal_aggregation == "all":
            return all_signals
        elif self.signal_aggregation == "any":
            # Return first signal for each market
            seen_markets = set()
            filtered = []
            for signal in all_signals:
                if signal.market_id not in seen_markets:
                    filtered.append(signal)
                    seen_markets.add(signal.market_id)
            return filtered
        elif self.signal_aggregation == "majority":
            # Return signals that appear from majority of strategies
            # Group by market and signal type
            signal_counts: Dict[tuple, List[StrategySignal]] = {}
            for signal in all_signals:
                key = (signal.market_id, signal.signal_type)
                if key not in signal_counts:
                    signal_counts[key] = []
                signal_counts[key].append(signal)
            
            # Keep signals with majority agreement
            majority_threshold = len(self.strategies) / 2
            filtered = []
            for key, signals in signal_counts.items():
                if len(signals) > majority_threshold:
                    # Average confidence
                    avg_confidence = sum(s.confidence for s in signals) / len(signals)
                    best_signal = signals[0]
                    best_signal.confidence = avg_confidence
                    filtered.append(best_signal)
            
            return filtered
        
        return all_signals
    
    def initialize(self, portfolio: VirtualPortfolio):
        """Initialize all strategies."""
        super().initialize(portfolio)
        for strategy in self.strategies:
            strategy.initialize(portfolio)
    
    def finalize(self, portfolio: VirtualPortfolio):
        """Finalize all strategies."""
        for strategy in self.strategies:
            strategy.finalize(portfolio)
        super().finalize(portfolio)
